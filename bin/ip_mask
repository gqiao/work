#!/usr/bin/env ruby

def mask(maski)
  masko = []
  i = 0
  #for i in 0..(mask / 8 - 1)
  while(i < maski / 8)
    masko[i] = 255
    i += 1
  end
  masko[i] = 255 - (2 ** (8 - maski % 8) - 1)

  masko
end

def last_host(ip1, ip2, ip3, ip4, mask)
  ip = [ip1, ip2, ip3, ip4]

  ip_idx = mask / 8
  mask_offset = mask % 8
  nr_zero = 8 - mask_offset
  block_size = 2 ** nr_zero
  subnet_id = ip[ip_idx] / block_size
  next_subnet_id = subnet_id+1

  h2 = ip
  h2[ip_idx] = next_subnet_id * block_size - 1
  for i in (ip_idx+1)..3
    h2[i] = 255
  end
  h2[3] -= 1

  h2
end

def first_host(ip1, ip2, ip3, ip4, mask)
  ip = [ip1, ip2, ip3, ip4]

  ip_idx = mask / 8
  mask_offset = mask % 8
  nr_zero = 8 - mask_offset
  block_size = 2 ** nr_zero
  subnet_id = ip[ip_idx] / block_size
  next_subnet_id = subnet_id+1

  h1 = ip
  h1[ip_idx] = subnet_id * block_size
  for i in (ip_idx+1)..3
    h1[i] = 0
  end
  h1[3] += 1

  h1
end

def broadcast(ip1, ip2, ip3, ip4, mask)
  ip = [ip1, ip2, ip3, ip4]

  ip_idx = mask / 8
  mask_offset = mask % 8
  nr_zero = 8 - mask_offset
  block_size = 2 ** nr_zero
  subnet_id = ip[ip_idx] / block_size
  next_subnet_id = subnet_id+1

  broadcast = ip
  broadcast[ip_idx] = next_subnet_id * block_size - 1
  for i in (ip_idx+1)..3
    broadcast[i] = 255
  end

  broadcast
end

def subnet(ip1, ip2, ip3, ip4, mask)
  ip = [ip1, ip2, ip3, ip4]

  ip_idx = mask / 8
  mask_offset = mask % 8
  nr_zero = 8 - mask_offset
  block_size = 2 ** nr_zero
  subnet_id = ip[ip_idx] / block_size

  subnet = ip
  subnet[ip_idx] = subnet_id * block_size
  for i in (ip_idx+1)..3
    subnet[i] = 0
  end

  subnet
end

def print_ip_mask(ip1, ip2, ip3, ip4, mask)
  ip = [ip1, ip2, ip3, ip4]
  #require 'rainbow'


  #puts "IP:         #{ip[0]}.#{ip[1]}.#{ip[2]}.#{ip[3]}                      ".insert(30,sprintf("%.8b.%.8b.%.8b.%.8b", ip[0], ip[1], ip[2], ip[3]))
  puts sprintf("IP:         %d.%d.%d.%d                                  ",ip[0], ip[1], ip[2], ip[3]).
    insert(30,sprintf("%.8b.%.8b.%.8b.%.8b", ip[0], ip[1], ip[2], ip[3]))

  m = mask(mask)
  puts sprintf("mask:       %d.%d.%d.%d                                  ",m[0], m[1], m[2], m[3]).
    insert(30,sprintf("%.8b.%.8b.%.8b.%.8b", m[0], m[1], m[2], m[3]))
  #puts sprintf("%.8b.%.8b.%.8b.%.8b\n", ip1,ip2,ip3,ip4).color(:green)

  if ip1 <= 127
    printf("Class A:   [0.0.0.0 - 127.255.255.255] \n")
    if ip1 == 127
      printf("Loopback \n")
    end
    if ip1 == 0 && ip2 == 0 && ip3 == 0 && ip4 == 0
      if mask == 0
        printf("Default route \n")
      elsif mask == 8
        printf("Addresses in this block refer to source hosts on \"this\" network \n")
      elsif mask == 32
        printf("Address may be used as a source address for this host on this network \n")
      else
        printf("Error N/A: check mask!!! \n")
      end
    end


  elsif ip1 <= 191
    printf("Class B:   [128.0.0.0 - 191.255.255.255] \n")
  elsif ip1 <= 223
    printf("Class C:   [192.0.0.0 - 223.255.255.255] \n")
  end

  sn = subnet(ip[0], ip[1], ip[2], ip[3], mask)
  printf("subnet:     %d.%d.%d.%d \n", sn[0], sn[1], sn[2], sn[3])

  fh = first_host(ip[0], ip[1], ip[2], ip[3], mask)
  lh = last_host(ip[0], ip[1], ip[2], ip[3], mask)
  printf("hosts:     [%d.%d.%d.%d - %d.%d.%d.%d] \n",
         fh[0], fh[1], fh[2], fh[3],
         lh[0], lh[1], lh[2], lh[3])

  bc = broadcast(ip[0], ip[1], ip[2], ip[3], mask)
  printf("broadcast:  %d.%d.%d.%d \n", bc[0], bc[1], bc[2], bc[3])



end



require 'yaml'
options = { }
CONFIG_FILE = File.join(ENV['HOME'], '.ip_mask.rc.yaml')
err_exit_1 = false


if File.exists?(CONFIG_FILE)
  config_options = YAML.load_file(CONFIG_FILE)
  options.merge!(config_options)
else
  if ARGV.empty?
    err_exit_1 = true
  end
end


require 'optparse'
option_parser = OptionParser.new do |opts|
  opts.on("-i IP", "--ip IP") do |ip|
    unless ip =~ /^.+\..+\..+\..+\/.+$/
      raise ArgumentError, "IP must be in 'xxx.xxx.xxx.xxx/xxx' format"
    end

    options[:ip] = ip
  end
end

option_parser.parse!
#puts options.inspect
puts "config is:  #{options.inspect}"


if err_exit_1 == true
  puts option_parser.help
  exit(0)
end


File.open(CONFIG_FILE, 'w') { |file| YAML::dump(options, file) }


# ip, m = options[:ip].split(/\//)
# mask = m.to_i
# i1, i2, i3, i4 = ip.split(/\./)
# ip1 = i1.to_i
# ip2 = i2.to_i
# ip3 = i3.to_i
# ip4 = i4.to_i
#puts "#{ip1}.#{ip2}.#{ip3}.#{ip4}/#{mask}"

require 'scanf'
ip1,ip2,ip3,ip4,mask = options[:ip].scanf("%d.%d.%d.%d/%d")
print_ip_mask(ip1, ip2, ip3, ip4, mask)
